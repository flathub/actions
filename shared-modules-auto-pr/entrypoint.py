#!/usr/bin/env python3

import os
import urllib
import contextlib
import tempfile
import shutil
import multiprocessing
import pathlib
import subprocess
import logging
import re
import sys

import yaml
from github import Github
import pygit2
from gi import require_version
require_version('Json', '1.0')
from gi.repository import Json


SHARED_MODULES = 'shared-modules'
_GITHUB_URL_PATTERN = re.compile(
    r"""
        ^git@github.com:
        (?P<org_repo>[^/]+/[^/]+?)
        (?:\.git)?$
    """,
    re.VERBOSE,
)

log = logging.getLogger(__name__)

handler = logging.StreamHandler(sys.stdout)
formater = logging.Formatter(
    '[%(levelname)-s] %(asctime)s %(message)s', "%Y-%m-%d %H:%M:%S")
handler.setFormatter(formater)
log.addHandler(handler)
log.setLevel(logging.INFO)


DISCLAIMER = (
    "<i>(This pull request was automatically generated by "
    "[flathub/actions/shared-modules-auto-pr]"
    "(https://github.com/actions/shared-modules-auto-pr). "
    "Please contact or mention `@bilelmoussaoui` if you have any "
    "questions or complaints.)</i>"
)


@contextlib.contextmanager
def indir(path):
    """
    >>> with indir(path):
    ...    # code executes with 'path' as working directory
    ... # old working directory is restored
    """

    old = os.getcwd()
    os.chdir(path)
    try:
        yield
    finally:
        os.chdir(old)


def get_app_id(repo_url: str) -> str:
    """
        Return the app-id based on the repository url
    """
    repo_base_path = urllib.parse.urlparse(repo_url).path
    app_id = repo_base_path.split('/')[-1]
    return app_id


def get_repo_path(repo_url: str) -> pathlib.Path:
    """
        Return the repository's temporary path
    """
    app_id = get_app_id(repo_url)
    repo_path = pathlib.Path(tempfile.gettempdir()).joinpath(app_id)
    return repo_path


def clone_repository(repo_url: str):
    """
        Clone the repository and fetch its submodules
    """
    repo_path = get_repo_path(repo_url)

    # Remove the repository for local tests
    if repo_path.exists():
        shutil.rmtree(repo_path, ignore_errors=True)

    repo = pygit2.clone_repository(repo_url, str(repo_path))
    repo.update_submodules(init=True)
    return repo


def find_shared_submodules(repo: pygit2.Repository) -> bool:
    """
        Check if the repository uses shared-modules as a submodule
    """
    submodules = repo.listall_submodules()
    shared_modules_found = False
    for submodule_name in submodules:
        submodule = repo.lookup_submodule(submodule_name)
        if submodule.url in ["git@github.com:flathub/shared-modules.git", "https://github.com/flathub/shared-modules.git"]:
            shared_modules_found = True
            break

    return shared_modules_found


def prepare_repository(repo_url: str, repo: pygit2.Repository) -> [str]:
    """
        Checks if the repo uses a module from shared-modules
        returns a list of the used shared-modules 
    """
    app_id = get_app_id(repo_url)
    repo_path = get_repo_path(repo_url)

    if not find_shared_submodules(repo):
        log.debug(f"No submodules found for {app_id}, skipping")
        return

    manifest_path = detect_manifest(app_id, repo_path)
    if not manifest_path:
        log.error(f"No manifest were found for {app_id}")
        return

    shared_modules = parse_manifest(manifest_path)
    if not shared_modules:
        log.error(f"No shared-modules found for {app_id}, skipping")

    return shared_modules


def parse_github_url(url):
    """
    Parses the organization/repo part out of a git remote URL.
    """
    if url.startswith("https:"):
        o = urllib.parse.urlparse(url)
        return o.path[1:]

    m = _GITHUB_URL_PATTERN.match(url)
    if m:
        return m.group("org_repo")
    else:
        raise ValueError(f"{url!r} doesn't look like a Git URL")


def bump_repository(repo_url: str):
    log.info(f"Preparing repo {repo_url}")
    app_id = get_app_id(repo_url)
    if len(app_id.split(".")) < 1:
        log.info(f"Repo {repo_url} doesn't seeem to be an app, skipping")
        return

    repository = clone_repository(repo_url)
    # If the repository uses a module from shared-modules
    if prepare_repository(repo_url, repository):
        log.info(f"Updating repo {repo_url}")
        update_repository(repository)


def open_pr(subject, body, branch):
    log.info("Opening pull request for branch %s", branch)
    github_token = os.environ["GITHUB_TOKEN"]
    g = Github(github_token)
    user = g.get_user()

    origin_url = (
        subprocess.check_output(("git", "remote", "get-url", "origin",))
        .decode("utf-8")
        .strip()
    )
    origin_repo = g.get_repo(parse_github_url(origin_url))

    if origin_repo.permissions.push:
        log.debug("origin repo is writable")
        repo = origin_repo
        fork = None
    else:
        log.debug("origin repo not writable; creating fork")
        fork = user.create_fork(origin_repo)
        repo = fork

    remote_url = f"https://{github_token}:x-oauth-basic@github.com/{repo.full_name}"

    base = origin_repo.default_branch
    head = "{}:{}".format(repo.owner.login, branch)
    pr_message = ((body or "") + "\n\n" + DISCLAIMER).strip()
    # Include closed PRs â€“ if the maintainer has closed our last PR, we don't want to
    # open another one.
    for pr in origin_repo.get_pulls(state="all", base=base, head=head):
        log.info(
            "Found existing %s PR: %s",
            "merged" if pr.is_merged() else pr.state,
            pr.html_url,
        )
        return

    subprocess.check_call(("git", "push", "-u", remote_url, branch))

    pr = origin_repo.create_pull(
        subject, pr_message, base, head, maintainer_can_modify=True,
    )
    log.info("Opened pull request %s", pr.html_url)


def update_repository(repo: pygit2.Repository):
    """
        Update the repository submodules
        commit the changes and create a merge request
    """
    submodule = repo.lookup_submodule(SHARED_MODULES)
    shared_modules = submodule.open()
    message = "Bump shared-modules"

    subprocess.check_call(['git', 'pull', 'origin', 'master'],
                          cwd=shared_modules.path)

    merge_branch = 'flathubbot/shared-modules'

    with indir(str(pathlib.Path(repo.path).parent)):
        subprocess.check_call(['git', 'checkout', 'HEAD@{0}'])
        subprocess.check_call(['git', 'add', SHARED_MODULES])
        subprocess.check_call(["git", "commit", "-am", message])

        subprocess.check_call(['git', 'checkout', '-b', merge_branch])
        open_pr(message, message, merge_branch)


def detect_manifest(app_id: str, repo_path: pathlib.Path):
    """
        Detect and return the manifest path
    """
    exts = ["yml", "yaml", "json"]
    for ext in exts:
        manifest = repo_path.joinpath(f"{app_id}.{ext}")
        if manifest.exists():
            return manifest


def get_yaml_shared_modules(modules: list) -> [str]:
    """
    Find the list of used shared-modules in a yaml manifest
    """
    shared_modules = []
    for module in modules:
        if isinstance(module, str) and module.startswith(SHARED_MODULES):
            shared_modules.append(module)
        elif isinstance(module, list):
            shared_modules.extend(get_yaml_shared_modules(module))
    return shared_modules


def get_json_shared_modules(root: Json.Node) -> [str]:
    """
        Find the list of used shared-modules in a json manifest
    """
    shared_modules = []
    elements = root.get_object().get_array_member('modules').get_elements()
    for elem in elements:
        module = elem.get_string()
        if module and module.startswith(SHARED_MODULES):
            shared_modules.append(module)
    return shared_modules


def parse_manifest(manifest_path: pathlib.Path) -> [str]:
    """
        Parse a Flatpak manifest and gets the list of used shared-modules
    """
    ext = manifest_path.suffix
    with open(manifest_path, 'r') as handle:
        data = handle.read()

    shared_modules = []

    if ext in [".json"]:
        parser = Json.Parser.new()
        parser.load_from_data(data, len(data))
        manifest_root = parser.get_root()
        shared_modules = get_json_shared_modules(manifest_root)
    elif ext in [".yml", ".yaml"]:
        manifest = yaml.safe_load(data)
        shared_modules = get_yaml_shared_modules(manifest['modules'])

    return shared_modules


if __name__ == "__main__":

    github_token = os.environ['GITHUB_TOKEN']
    g = Github(github_token, per_page=200)

    org = g.get_organization('flathub')
    repos = []

    for repo in org.get_repos():
        repos.append(repo.html_url)

    with multiprocessing.Pool(multiprocessing.cpu_count()) as pool:
        pool.map(bump_repository, repos)
